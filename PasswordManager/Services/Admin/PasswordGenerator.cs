using PasswordManager.Common;
using PasswordManager.Dto.Admin;
using PasswordManager.Dto.Credentials;
using PasswordManager.Interfaces.Admin;
using System.Security.Cryptography;
using System.Text;

namespace PasswordManager.Services.Admin
{
    public class PasswordGenerator : IPasswordGenerator
    {
        private readonly ITokenService _tokenService;
        private readonly IResponseGeneratorService _responseGeneratorService;
        private static readonly string ValidChars;

        public PasswordGenerator(ITokenService tokenService, IResponseGeneratorService responseGeneratorService)
        {
            _tokenService = tokenService;
            _responseGeneratorService = responseGeneratorService;
        }
        static PasswordGenerator()
        {
            // Initialize ValidChars in the static constructor
            ValidChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-_=+";
        }

        // Number of iterations for PBKDF2
        private const int Iterations = 10000;

        // Length of the derived key in bytes
        private const int DerivedKeyLength = 256 / 8;

        public async Task<ReturnResponse<string>> GenerateAndStorePassword(string authToken, PasswordGeneratorDto passwordGeneratorDto)
        {

            var checkAuthorizationTokenIsValid = await _tokenService.DecodeToken(authToken);
            if (!checkAuthorizationTokenIsValid.Status)
            {
                return await _responseGeneratorService.GenerateResponseAsync<string>(
                 false, StatusCodes.Status401Unauthorized, checkAuthorizationTokenIsValid.Message, null);
            }
            if (!checkAuthorizationTokenIsValid.Data.Status)
            {
                return await _responseGeneratorService.GenerateResponseAsync<string>(
              false, StatusCodes.Status401Unauthorized, "InValid token", null);
            }

            // Generate a random password
            string password = GenerateRandomPassword(passwordGeneratorDto);

            // Generate a random salt
            string salt = GenerateSalt();

            // Hash the password with the generated salt
            string hashedPassword = HashPassword(password, salt);

            // In a real-world scenario, you would store the hashed password and salt in the database
            Console.WriteLine("Generated Password: " + password);
            Console.WriteLine("Salt: " + salt);
            Console.WriteLine("Hashed Password: " + hashedPassword);

            return await _responseGeneratorService.GenerateResponseAsync<string>(true, StatusCodes.Status200OK, "Your AutoGeneratedPassowrd", password);
        }

        private static string GenerateRandomPassword(PasswordGeneratorDto passwordGeneratorDto)
        {
            // Use ValidChars in the method
            string validCharsWithUserAndWebsite = $"{ValidChars}{passwordGeneratorDto.Username}{passwordGeneratorDto.WebsiteName}";
            const int passwordLength = 15;

            using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())
            {
                char[] password = new char[passwordLength];
                int validCharCount = validCharsWithUserAndWebsite.Length;

                for (int i = 0; i < passwordLength; i++)
                {
                    byte[] randomBytes = new byte[1];
                    rng.GetBytes(randomBytes);
                    password[i] = validCharsWithUserAndWebsite[randomBytes[0] % validCharCount];
                }

                return new string(password);
            }
        }

        private static string HashPassword(string password, string salt)
        {
            using (Rfc2898DeriveBytes pbkdf2 = new Rfc2898DeriveBytes(password, Encoding.UTF8.GetBytes(salt), Iterations))
            {
                byte[] hashBytes = pbkdf2.GetBytes(DerivedKeyLength);

                // Combine salt and hash
                byte[] combinedBytes = new byte[salt.Length + hashBytes.Length];
                Buffer.BlockCopy(Encoding.UTF8.GetBytes(salt), 0, combinedBytes, 0, salt.Length);
                Buffer.BlockCopy(hashBytes, 0, combinedBytes, salt.Length, hashBytes.Length);

                // Convert to Base64 for storage
                return Convert.ToBase64String(combinedBytes);
            }
        }

        private static string GenerateSalt()
        {
            byte[] saltBytes = new byte[16];
            using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())
            {
                rng.GetBytes(saltBytes);
            }
            return Convert.ToBase64String(saltBytes);
        }
    }
}
